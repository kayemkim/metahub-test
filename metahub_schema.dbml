// MetaHub Database Schema in DBML format - UPDATED VERSION
// Use at https://dbdiagram.io to generate ERD

Project MetaHub {
  database_type: 'PostgreSQL'
  Note: '''
    MetaHub - Metadata Management System (Latest Architecture - 2025-09)
    - Taxonomies: Database-managed hierarchical terms with integrated content
    - CodeSets: Database-managed code/value pairs  
    - Meta Types: Code-managed type definitions (app/core/meta_types.py)
    - Meta Items & Values: Database-managed with unified JSON storage
    
    🆕 LATEST: Term table consolidation and unified JSON storage
    🗑️ REMOVED: tx_term_content intermediate table 
    🗑️ REMOVED: Legacy multi-column approach (value_json, code_id, taxonomy_term_id)
    🗑️ REMOVED: Separate taxonomy term junction table
    ✅ IMPROVED: Merged tx_term and tx_term_content for simpler structure
    ✅ IMPROVED: Direct tx_term → tx_term_version relationship
    ✅ IMPROVED: Single value_json column with complete data enrichment
    ✅ IMPROVED: Unified API with consistent {"type": "...", ...} structure
    ✅ IMPROVED: Spring @Transactional style transaction management
  '''
}

// Taxonomy Domain
Table tx_taxonomy {
  taxonomy_id varchar(36) [pk]
  taxonomy_code varchar(100) [unique, not null]
  name varchar(200) [not null]
  description text
  created_at timestamp [default: `now()`]
}

Table tx_term {
  term_id varchar(36) [pk]
  taxonomy_id varchar(36) [ref: > tx_taxonomy.taxonomy_id]
  term_key varchar(150) [not null]
  display_name varchar(200) [not null]
  parent_term_id varchar(36) [ref: > tx_term.term_id]
  current_version_id varchar(36) [note: '🆕 MERGED: Content management integrated into term']
  created_at timestamp [default: `now()`]
  
  indexes {
    (taxonomy_id, term_key) [unique]
  }
}

Table tx_term_version {
  version_id varchar(36) [pk]
  term_id varchar(36) [ref: > tx_term.term_id]
  version_no integer [not null]
  body_json text
  body_markdown text
  valid_from timestamp [default: `now()`]
  valid_to timestamp
  author varchar(200)
  change_reason varchar(1000)
  
  indexes {
    (term_id, version_no) [unique]
  }
}

// CodeSet Domain
Table cm_codeset {
  codeset_id varchar(36) [pk]
  codeset_code varchar(100) [unique, not null]
  name varchar(200) [not null]
  description text
  created_at timestamp [default: `now()`]
}

Table cm_code {
  code_id varchar(36) [pk]
  codeset_id varchar(36) [ref: > cm_codeset.codeset_id]
  code_key varchar(150) [not null]
  current_version_id varchar(36)
  created_at timestamp [default: `now()`]
  
  indexes {
    (codeset_id, code_key) [unique]
  }
}

Table cm_code_version {
  code_version_id varchar(36) [pk]
  code_id varchar(36) [ref: > cm_code.code_id]
  version_no integer [not null]
  label_default varchar(200) [not null]
  sort_order integer [default: 0]
  parent_code_id varchar(36) [ref: > cm_code.code_id]
  valid_from timestamp [default: `now()`]
  valid_to timestamp
  tx_time timestamp [default: `now()`]
  is_active boolean [default: true]
  extra_json text
  
  indexes {
    (code_id, version_no) [unique]
  }
}

// 🆕 UPDATED: Custom Meta Management (Code-based Types)
// ❌ REMOVED: custom_meta_type table (now managed in app/core/meta_types.py)
// ❌ REMOVED: custom_meta_type_codeset table (validation in code)  
// ❌ REMOVED: custom_meta_type_taxonomy table (validation in code)

Table custom_meta_group {
  group_id varchar(36) [pk]
  group_code varchar(100) [unique, not null]
  display_name varchar(200) [not null]
  sort_order integer [default: 0]
  created_at timestamp [default: `now()`]
}

Table custom_meta_item {
  item_id varchar(36) [pk]
  item_code varchar(150) [unique, not null]
  display_name varchar(200) [not null]
  group_id varchar(36) [ref: > custom_meta_group.group_id]
  type_kind varchar(30) [default: 'PRIMITIVE', note: '🆕 DIRECT STORAGE: PRIMITIVE|STRING|CODESET|TAXONOMY (no FK needed)']
  is_required boolean [default: false]
  default_json text
  selection_mode varchar(10) [default: 'SINGLE', note: 'SINGLE|MULTI for TAXONOMY']
  created_at timestamp [default: `now()`]
}

// Meta Values (Unchanged)
Table custom_meta_value {
  value_id varchar(36) [pk]
  target_type varchar(50) [not null, note: 'table, column, job, etc.']
  target_id varchar(200) [not null]
  item_id varchar(36) [ref: > custom_meta_item.item_id]
  current_version_id varchar(36)
  created_at timestamp [default: `now()`]
  
  indexes {
    (target_type, target_id, item_id) [unique]
    (target_type, target_id)
  }
}

Table custom_meta_value_version {
  version_id varchar(36) [pk]
  value_id varchar(36) [ref: > custom_meta_value.value_id]
  version_no integer [not null]
  value_json text [note: '🆕 UNIFIED JSON FORMAT: {"type": "PRIMITIVE|STRING|CODESET|TAXONOMY", ...} with enriched reference data']
  valid_from timestamp [default: `now()`]
  valid_to timestamp
  tx_time timestamp [default: `now()`]
  author varchar(200)
  reason varchar(1000)
  
  indexes {
    (value_id, version_no) [unique]
  }
}

// ❌ REMOVED: custom_meta_value_version_term table 
// Multi-term taxonomy values now stored in value_json as:
// {"type": "TAXONOMY", "selection_mode": "MULTI", "terms": [{"term_id": "...", "term_key": "...", ...}]}

// 📊 ARCHITECTURE SUMMARY:
// Before: 14+ tables (complex multi-table approach with separate term/content storage)
// After: 10 tables (streamlined with unified JSON storage and merged term tables)
// 
// 🆕 LATEST CHANGES (2025-09):
// ❌ REMOVED: custom_meta_type, custom_meta_type_codeset, custom_meta_type_taxonomy (moved to code)
// ❌ REMOVED: custom_meta_value_version_term (stored in JSON now)  
// ❌ REMOVED: tx_term_content intermediate table (merged into tx_term)
// ❌ REMOVED: legacy value_json, code_id, taxonomy_term_id columns
// ✅ ADDED: unified value_json column with enriched reference data
// ✅ ADDED: current_version_id to tx_term (merged from tx_term_content)
// ✅ SIMPLIFIED: tx_term_content_version → tx_term_version with direct term_id reference
// 
// Benefits:
// ✅ Better type safety with MetaTypeKind enum
// ✅ No complex JOIN queries for type checking or taxonomy terms
// ✅ Much faster meta value operations (single column read/write)
// ✅ Simplified term content management (2-table instead of 3-table structure)
// ✅ Direct term → version relationship without intermediate table
// ✅ Git-based type versioning
// ✅ Compile-time type validation
// ✅ Unified API structure with consistent JSON format
// ✅ Enriched JSON includes full reference data (labels, display names, etc.)
// ✅ Single transaction writes with @transactional decorator